<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rmar&#39;s Guide</title>
    <link>https://dektoud.github.io/blog/post/</link>
    <description>Recent content in Posts on Rmar&#39;s Guide</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Ryan Martin</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://dektoud.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Calling Fortran DLL&#39;s from Python and Julia</title>
      <link>https://dektoud.github.io/blog/post/fortran_dlls/</link>
      <pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dektoud.github.io/blog/post/fortran_dlls/</guid>
      <description>The standard Python library contains a package called ctypes which provides interfaces to foreign functions that are found in shared libraries. With the Intel compiler, a Fortran function or subroutine can be exported to dll by ensuring that the !DEC$ is present to define the exported symbol:
! Note: this only works with the Intel Compiler subroutine sqr(val) !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:&#39;sqr&#39; :: sqr integer, intent(inout) :: val val = val ** 2 end subroutine sqr  If the above subroutine is contained in the example.</description>
    </item>
    
    <item>
      <title>AutoReloading PyCall imported Python modules in Julia</title>
      <link>https://dektoud.github.io/blog/post/julia-autoreloading/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dektoud.github.io/blog/post/julia-autoreloading/</guid>
      <description>AutoReloading PyCall Imported Modules One of the major components of being productive with my Python workflows was the IPython magic command %autoreload 2. This magic command throws a hook on the start of running an IPython cell, and recompiles Python modules where source code changes are detected. This is probably the single most useful component of my workflow since I modify and work on packages in Sublime and test and develop the code in an interactive Jupyter notebook.</description>
    </item>
    
    <item>
      <title>Transitioning from Python to Julia</title>
      <link>https://dektoud.github.io/blog/post/julia/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dektoud.github.io/blog/post/julia/</guid>
      <description>Two Languages Python suffers from a two language problem. On one end the syntax, vast and mature library ecosystem, dynamic style and interactive workflows that Python offers provide a flexible and productive prototyping environment for new ideas. However, when moving past initial ideas and beginning to apply those ideas to datasets of meaningful size, pythonistas often look to things like Cython, Numba, F2PY or C++ to gain additional performance. In my research group we spend much of our time developing and implementing ideas using Python (or Matlab), and once those ideas are demonstrated, often a follow-up Fortran implementation is generated so that statically compiled executables implementing those ideas can reach as wide an audience as possible.</description>
    </item>
    
    <item>
      <title>Methods to write fast subroutines for Python - minimal computer science required</title>
      <link>https://dektoud.github.io/blog/post/fast_subroutines/</link>
      <pubDate>Tue, 07 Feb 2017 21:00:01 -0700</pubDate>
      
      <guid>https://dektoud.github.io/blog/post/fast_subroutines/</guid>
      <description>Note: I am not a Python or programming expert. There are probably better ways to optimize subroutines, but that is not the point of this post!.
 Introduction Python is an impressive programming language for a beginning programmer/scientist. Syntax is easy to learn, the language is expressive (in the sense that it reads like it is doing things), and there are immense guides out there on the web to learn nearly any aspect of Python you can think of.</description>
    </item>
    
  </channel>
</rss>